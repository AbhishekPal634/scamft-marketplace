
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.38.4";
import { corsHeaders } from "../_shared/cors.ts";

const BATCH_SIZE = 10; // Only process 10 NFTs at a time

// Sample NFT data for when none is provided
const generateSampleNFTs = (count = 10) => {
  return Array.from({ length: count }, (_, i) => ({
    title: `Sample NFT #${i + 1}`,
    description: `This is a sample NFT generated by the seed-nfts function (${i + 1})`,
    price: Math.floor(Math.random() * 1000) / 100 + 0.1, // Random price between 0.1 and 10.1
    image_url: `https://source.unsplash.com/random/300x300?nft=${i}`,
    creator_id: "00000000-0000-0000-0000-000000000000", // Default creator ID
    category: ["Art", "Photography", "Music", "Sports", "Virtual Worlds"][Math.floor(Math.random() * 5)],
    tags: ["digital", "art", "nft", "blockchain"],
    editions_total: 10,
    editions_available: 10,
    likes: Math.floor(Math.random() * 100),
    views: Math.floor(Math.random() * 1000),
    created_at: new Date().toISOString()
  }));
};

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    // Create a Supabase client with the service role key
    // This allows us to bypass RLS policies
    const supabaseUrl = Deno.env.get("SUPABASE_URL") ?? "";
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? "";
    
    // Check if the service role key is available
    if (!supabaseServiceKey) {
      throw new Error("SUPABASE_SERVICE_ROLE_KEY is not available in environment variables");
    }
    
    const supabaseAdmin = createClient(
      supabaseUrl,
      supabaseServiceKey,
      {
        auth: {
          persistSession: false,
        },
      }
    );

    // Get the request body or default values
    let requestBody;
    try {
      requestBody = await req.json();
    } catch (error) {
      // If parsing fails, use an empty object
      console.error("Error parsing request body:", error);
      requestBody = {};
    }
    
    const { 
      nfts = null, 
      clearExisting = false, 
      startIndex = 0, 
      count = 10,
      generateSample = true // New option to generate sample data
    } = requestBody;
    
    // If no NFTs are provided and generateSample is true, create sample NFTs
    let nftsToUse = nfts;
    if ((!nfts || !Array.isArray(nfts) || nfts.length === 0) && generateSample) {
      console.log("No NFTs provided, generating sample data");
      nftsToUse = generateSampleNFTs(count);
    } else if (!nfts || !Array.isArray(nfts)) {
      throw new Error("No NFTs provided or invalid format, and generateSample is false");
    }
    
    // Limit the number of NFTs to process
    const nftsToProcess = nftsToUse.slice(startIndex, startIndex + count);
    
    if (nftsToProcess.length === 0) {
      return new Response(
        JSON.stringify({
          success: true,
          message: "No more NFTs to process",
          startIndex,
          totalNFTs: nftsToUse.length,
          processed: 0,
        }),
        {
          headers: { ...corsHeaders, "Content-Type": "application/json" },
          status: 200,
        }
      );
    }

    // Check if we need to clear existing NFTs
    if (clearExisting) {
      console.log("Clearing existing NFTs...");
      const { error: deleteError } = await supabaseAdmin
        .from("nfts")
        .delete()
        .neq("id", "00000000-0000-0000-0000-000000000000"); // Safety check to avoid deleting everything

      if (deleteError) {
        throw new Error(`Error clearing existing NFTs: ${deleteError.message}`);
      }
      console.log("Existing NFTs cleared successfully");
    }

    // Process NFTs in small batches
    console.log(`Processing batch of ${nftsToProcess.length} NFTs starting at index ${startIndex}`);
    
    const { data, error } = await supabaseAdmin
      .from("nfts")
      .insert(nftsToProcess)
      .select();

    if (error) {
      throw new Error(`Error inserting NFTs: ${error.message}`);
    }

    return new Response(
      JSON.stringify({
        success: true,
        message: `Successfully inserted ${data?.length || 0} NFTs`,
        data: data || [],
        startIndex,
        nextIndex: startIndex + count,
        totalNFTs: nftsToUse?.length || 0,
        processed: nftsToProcess.length,
        remaining: Math.max(0, (nftsToUse?.length || 0) - (startIndex + count)),
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 200,
      }
    );
  } catch (error) {
    console.error("Error:", error.message);
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message,
      }),
      {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
        status: 400,
      }
    );
  }
});
